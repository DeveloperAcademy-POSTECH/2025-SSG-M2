>[!question]
>GQ1. iOS 면접은 어떻게 진행 될까?
>GQ2. Swift 문법을 공부하면서 어떻게 적용 할 것인가?

### ===CPU와 메모리 간의 데이터 교환은 어떻게 이루어 지나요?===

- 세부 GQ : 데이터 교환 속도를 높이기 위해 컴퓨터 시스템에는 어떤 장치들이 사용 되나요?

**-> 데이터 교환 속도를 높이기 위해 컴퓨터 시스템에는 CPU와 메모리, 그리고 주변 장치 간의 병목을 줄이는 여러 장치나 기술들이 있습니다.**

  대표적으로 캐시 *메모리 , DMA, "고속버스"*를 예로 듭니다.

- **캐시 메모리 (Cache Memory)**

-> CPU는 처리 속도가 매우 빠르기 때문에, 상대적으로 느린 메인 메모리 (RAM)에서 데이터를 가져오면 시간이 걸립니다.

이때 캐시 메모리는 자주 사용하는 데이터를 미리 저장해서 CPU가 훨씬 빠르게 접근할 수 있게 도와줍니다.

- **DMA (Direct Memory Access)**

-> 입출력 장치가 데이터를 메모리로 보낼 때는 CPU가 중간에서 전송을 관리하지만, DMA를 사용하면 CPU를 거치지 않고 직접 메모리와 데이터를 주고받을 수 있습니다.

이렇게 하면 CPU는 다른 작업에 집중할 수 있어 전체 성능이 올라갑니다.

ex) 고해상도 영상 파일을 디스크에서 메모리로 옮길때 CPU 없이도 빠르게 처리

- **고속 버스 구조 (PCle, NVMe)**

-> 컴퓨터 내부의 데이터 통로인 버스 속도를 높이면 전체적인 데이터 교환 속도가 빨라집니다.
특히 최근에는 NYMe SSD 처럼 고속 저장장치를 PCle 버스에 연결해서
기존의 SATA보다 훨씬 빠른 입출력 속도를 얻고 있습니다.

다시 말해

이런 장치들을 모두 CPU가 대기하지 않고 데이터를 효율적으로 주고받게 해주는 역할을 하며, 시스템 전체의 응답성과 처리 속도를 높이는 데 핵심적인 역할을 합니다.


### ===iOS에서의 메모리 구조와 관리 방식에 대해 자세히 설명해주세요===

   -> Unix 기반의 메모리 모델을 따르며 크게 다음과 같이 나눌 수 있습니다.
   
   - Text-Segment : 코드(기계어)가 저장된 (읽기전용)
   - Data-Segment : 전역변수, static 변수 저장
   - Heap : 동적 메모리 저장
   - Stack : 함수 호출 시 지역 변수, 매개변수 저장
   - Memory-mapped : 시스템 라이브러리, 프레임워크 등

다음과 같음 전반적으로 iOS 메모리를 효율적으로 관리하기 위해 ARC(자동 메모리 관리 시스템)을 사용 합니다.
정리하면, iOS는 Unix 기반 메모리 구조를 따르면서도, ARC를 통해 개발자가 직접 메모리 해제를 하지 않아도 되는 안정적이고 자동화된 메모리 관리 시스템을 가지고 있습니다.
하지만 강한 순환 참조처럼 ARC의 맹점을 이해하고, 적절한 키워드 (weak, unowned)를 사용해야 메모리 누수를 방지할 수 있습니다.


===2-1 Swift의 값 타입(Value Type)과 참조 타입(Reference Type)은 각각 힙과 스택 중 어디에 주로 할당되나요? 그 이유는 무엇일까요?===

-> 먼저 값타입 (Value Type)
struct나 enum 같은 값 타입들은 스택에 할당됩니다. 스택은 함수가 호출될 때 지역변수들이 저장되는 공간인데, 여기서 중요한 점은 값 타입은 변수에 실제 데이터가 직접 저장된다는 것입니다. 그래서 다른 변수에 할당할 때 값이 복사 된다고 보면 됩니다.

참조 타입인 class는 힙에 할당 됩니다.
힙은 동적으로 메모리를 할당하는 공간이고, 변수에는 실제 데이터가 아니라 힙에 있는 객체의 주소값이 저장 됩니다.
그래서 다른 변수에 할당 하면 같은 객체를 가리키데 됩니다.

그럼 왜 굳이 이렇게 나눠야 할까요?
스텍은 함수 호출과 함께 자동으로 메모리가 관리되고 접근 속도가 빠릅니다.
값 타입은 크기가 정해져 있어서 스텍에 적합 합니다.
반면 힙은 크키가 동적으로 변할 수 있는 객체들을 저장하기에 적합하고, 여러 변수가 같은 객체를 참조할 수 있어서 참조 타입에 맞습니다.

이런 구조 덕분에 Swift는 메모리를 효율적으로 사용하게 됩니다.

3. **iOS 앱의 생명주기(App Life Cycle)에 대해 설명해주세요.**
-> 앱 상태는 계속 변합니다. 그래서 상태가 바뀔 때마다 할 일을 코드에 써줘야 합니다.

보통 5단계로 나뉘어 지는데,

3-1. Not Running (실행되지 않음)
- 앱이 아직 실행되지 않았거나 완전히 종료된 상태
- 스마트폰 홈 화면에서 앱 아이콘만 보이는 상태

3-2 Inactive(비활성)

- 앱이 실행되고 있지만 사용자와 상호작용하지 않은 상태
- ex) 전화가 와서 알림이 떳을 때, 앱은 켜져 있지만 터치할 수 없는 상태

3-3 Active (활성)

- 앱이 화면에 보이고 사용자가 실제로 사용하고 있는 상태
- 터치, 스와이프 등 모든 상호작용이 가능한 상태

3-4 Background(백그라운드)

- 앱이 실행 중이지만 화면에 보이지 않는상태
- 홈 버튼을 눌러 다른 앱으로 갔을 때
- 음악 앱처럼 백그라운드에서도 계속 실행되는겨우

3-5 Suspended (일시정지)

- 앱이 메모리에는 있지만 코드가 실행되지 않는 상태
- 시스템이 메모리 부족 시 자동으로 종료시킬 수 있는 상태


ex) 카카오톡 앱을 예로 들어보면:

- 앱 아이콘 터치 → **Inactive** (로딩 중)
- 채팅 화면 사용 → **Active** (메시지 주고받기)
- 홈 버튼 누름 → **Background** (메시지 알림은 계속 받음)
- 시간이 지나면 → **Suspended** (메모리에만 있고 실행 안됨)
- 메모리 부족 시 → **Not Running** (완전 종료)


근데 이런걸 왜 알아야 됨????
개발자는 각 상태에서 어떤 작업을 해야 하는지 알아야 됩니다.

1) Active가 될때 : 화면을 새로고침하거나 타이머 시작
2) Background로 갈 때 : 중요한 데이터 저장, 타이머 정지
3) Suspended 되기 전 : 사용자 데이터 백업
   
   이럴 때 각 단계에 맞는 적절한 처리를 해야 사용자가 자연스럽고 안정적인 앱 경험을 할 수 있습니다.

### ===**iOS 앱에서 데이터를 저장하는 방법에는 어떤 것들이 있나요?**===

대표적으로 4가지로 나눌 수 있습니다.

데이터의 크기, 보안성, 복잡도, 동기화 필요 여부에 따라 4가지 중에 선택을 합니다.

1. UserDefaults
   - 간단한 설정값을 저장할 때 사용 합니다.
     ex) 다크모드 , 로그인 여부
   - 앱이 종료되어도 값이 유지 됩니다.

1. Keychain
- 비밀번호, 토큰 등 민감한 데이터를 암호화하여 안전하게 저장 합니다.
	- 보안이 중요한 데이터를 저장할 때 사용합니다.
	  ex) 로그인 토큰, Apple 로그인 사용자 ID 저장

1. File System (Document Directory)
   - 텍스트, 이미지, JSON 등 파일 형태로 직접 저장할 때 사용 합니다.
   - 앱 내부 파일로 저장되며, 사용자 접근은 불가합니다.
     ex) 유저가 찍은 사진, 다운로드한 PDF 파일 저장
     
   - CoreData / Realm / SwiftData (로컬 데이터베이스)
     -> 구조화된 데이터를 효율적으로 저장하고, 검색/필터링할 수 있습니다.

- CloudKit / Firebase (클라우드 기반 저장)
  - 기기 간 데이터 동기화가 필요할 때 사용
    ex) iCloud에 사진 백업, Firebase로 유저 데이터 저장


정리 : 데이터의 민감도, 구조, 저장기간, 동기화 필요 여부를 기준으로 저장 방식을 선택 합니다.

- ===`UserDefaults`의 사용 시 주의할 점은 무엇인가요?===

1. 대용량 데이터 저장 x
-> 이미지, JSON, 배열 등 큰 데이터를 저장하면 성능 저하가 발생 함
why? UserDefaults는 앱 실행 시 전체를 메모리에 로드하기 때문입니다.

2. 민감한 정보 저장 x
-> 비밀번호, 토큰 같은 민감한 데이터는 절대 저장 하면 안됩니다.
why? 암호화되지 않고 저장되므로 보안에 취약!!!!
이때는 Keychain사용 추천

- ===Core Data와 SQLite의 차이점은 무엇이며, 각각 언제 사용하면 좋나요?===

- Core Data : 객체 지향 데이터 관리 프레임워크
  -> 애플이 제공하는 ORM (Object Realational Mapping) 기반 프레임워크 로써
  데이터를 객체처럼 관리할 수 있어서 Swift 코드와 자연스럽게 연동 되며, iCloud 연동도 가능 합니다.
  -> 자동 변경 감지 - **NSFetchedResultsController** , Undo/Redo, 관계 모델링 등 고급 기능을 제공합니다.
  
  그럼 언제 사용 하는가?
  - 복잡한 데이터 구조 (관계형 데이터)
  - SwiftUI , UIKit과 잘 연동되는 방식이 필요할 때
  - 객체 중심의 상태 관리가 필요할 때


- SQLite : 경량 SQL 데이터베이스 엔진
-> SQL 문법으로 데이터를 직접 다루는 방식 입니다.
직접 쿼리를 작성해야 하며, Swift 객체와의 매핑은 수동 처리해야 하며, 외부 라이브러리나
직접 래핑 코드가 필요할 수 있습니다.

그럼 언제 씀??
- 이미 SQL 기반 DB 경험이 있고 쿼리 제어가 필요한 경우
- Core Data의 오버헤드가 부담스러운 단순 구조
- 타 플랫폼 (Android, 서버 등)과 데이터 호환성이 필요한 경우에 사용합니다.
  
  정리하면
  
  Core Data는 Swift 개발에 최적화된 객체 지향적 방식,
  SQLite는 경량 SQL DB로 직접 제어가 필요한 상황에 적합합니다.
  
  
  
### API 호출이 실패했을 때 재시도 로직을 구현하려면 어떻게 하시겠습니까?
 -> 일단 먼저 API 호출이 실패 했을 때는, 단순히 실패를 처리하는 것에 그치지 않고,
 사용자의 요청이 정산적으로 처리될 수 있도록 재시도 로직을 구현하는 것이 중요합니다.
 
 따라서, 재시도 로직에 세가지 요소를 구현할 것 같습니다.
 
 1. 최대 재시도 횟수 제한 : 무한 재시도를 막기 위해 maxRetryCount를 설정해서 시스템 과부하나 무한 루프를 방지합니다.
 2. 지연 시간 설정 (Delay) : 바로 재시도하지 않고, 1초, 2초, 4초 처럼 점점 대기 시간을 늘리는 Exponential Backoff 전략을 적용할 수 있습니다.
 3. 재시도 조건 분기 : 예를 들어, 500번대 서버 오류나 네트워크 오류처럼 일시적인 실패만 재시도하고, 400번대 클라이언트 오류는 바로 실패 처리합니다.
    
    Swift 에서는 async/await 과 Task.sleep()을 활용 하거나,
    Combine의 retry, 또는 라이브러리를 통해 구현할 수 있습니다.


===URLSession의 캐싱 정책을 활용한 오프라인 대응 방법은?===

**URLSession

-> iOS에서 네트워크 통신을 처리할 때 사용하는 핵심 클래스 입니다.
예를들어, 서버에서 JSON 데이터를 가져오거나, 이미지를 다운로드 하거나, 파일 업로드/다운로드 작업할 떄 사용됩니다.

URLSession은 내부적으로 비동기 방식으로 작동하고, 크게 3가지 방식으로 구성 됩니다.

1. 기본 세션 (default)
-> 일반적인 데이터 요청에 사용되며, 캐시 쿠키, 인증 정보 등을 기본으로 처리 합니다.

2. 임시 세션 (ephemeral)
-> 캐시나 쿠기 등을 저장하지 않고, 민감한 정보 요청에 적합합니다.

3. 백그라운드 세션 (background)
-> 앱이 백그라운드 상태여도 대용량 다운로드나 업로드가 계속 되도록 해주는 구성입니다.


-> URL Request의 cachePolicy 속성을 설정하면 네크워크 연결이 없거나 느릴 때 캐시 데이터를 사용할지 여부를 제어 할 수 있습니다.

예를 들어  returnCacheDataElseLoad 옵션을 사용하면 네트워크에 연결되어 있지 않을 때 기존에 저장된 케시 데이터를 우선 사용하고, 없으면 네트워크 요청을 시도합니다.

``` swift
var request = URLRequest(url: url)
request.cachePolicy = .returnCacheDataElseLoad
```

또한 URLChache를 통해 응답 데이터를 디스크나 메모리에 저장하고 관리할 수 있으며, 캐시 용량도 직접 설정할 수 있습니다.

이정도 면 사용자가 오프라인 상태에서도 이전에 조회했던 데이터를 볼 수 있어 더 나은 사용자 경험을 제공한다고 생각 합니다.

===백그라운드에서 대용량 파일을 다운로드할 때 고려사항은?===

-> URLSession의 background configuration 사용 URLSessionConfiguration.background를 사용하면 앱이 종료되거나 백그라운드 상태에서도 다운로드가 계속 되며, 완료 시 시스템이 없을 다시 실행에 알려줍니다.

```swift
let config = URLSessionConfiguration.background(withIdentifier: "com.example.download")
let session = URLSession(configuration: config, delegate: self, delegateQueue: nil)
```

- 파일 저장 위치 지정
-> 다운로드가 완료되면 didFinishDownloadingTo 델리게이트 메서드를 통해 임시 위치로 전달되므로, 이를 적절한 디렉토리로 이동시켜야 합니다.

- 충분한 저장 공간 확인
-> 대용량 파일인 경우 사용자 기기의 저장 공간이 부족할 수 있으므로, 사전 확인 또는 실패 시 처리 로직을 준비해둬야 합니다.

- 네트워크 상태 고려
-> Wi-Fi 연결 시에만 다운로드하거나, 셀룰러 데이터 사용 여부를 사용자가 선택할 수 있도록 하는 것도 중요한 사용자 배려 입니다.

- 에너지 효율과 사용자 알림
-> 백그라운드에서 작업이 오래 걸릴 수 있으므로 진행 상태를 사용자에게 적절히 알리고, 필요시 취소할 수 있도록 해야 합니다.

이렇게 하면 안정적으로 대용량 파일을 다운로드하면서도, 사용자 경험을 시스템 자원을 모두 고려한 처리가 가능하다고 생각 합니다.


### Swift의 문자열(String) 다루기와 관련된 주요 기능은 무엇이 있나요?

-> 여기서 대답 할 때 Point는 "문자열을 다룬다" 느낌이 아니라,
Swift가 문자열을 얼마나 강력하고 안전하게 처리하는 지를 집어 내는게 중요하다

-> Swift에서는 String 타입이 굉장히 강력하고 유니코드(Unicode) 기반으로 설계되어 있어서 다양한 언어, 이모지 등을 정확하게 처리할 수 있습니다.

주오 기능은

- 문자열 길이 확인
-> count 속성을 사용해서 글자 수를 셀 수 있습니다. (유니코드 기준)

```swift
let str = "Hello"
print(str.count) // 5
```

- 접두사/접미사 확인
   -> hasPrefix(_:), hasSuffix(__:)로 특정 문자열로 시작하거나 끝나는지 확인할 수 있습니다
   
- 문자열 수정
  삽입 : insert (_:at:)
  삭제 : remove(at:), removeSubrange(_:)
  교체: replacingOccurrences(of:with:)

- 부분 문자열 (Substring)
-> 인덱스를 이용해 문자열을 자를 수 있는데, Swift는 안전하게 String.Index를 통해 슬라이싱 합니다.

```swift
let str = "Swift"
let index = str.index(str.startIndex, offsetBy: 2)
print(str[index]) // "i"
```

- 문자열 분리/결합

1) components(separatedBy:) -> 문자열을 배열로 분리
2) joined() -> 배열을 문자열로 합치기

- 다양한 문자 처리

-> Swift의 String은 grapheme cluster 단위로 처리되어 이모지나 한글 조합도 정확하게 동작 합니다.

등이 있습니다.