[[Class(클래스) Struct(구조체) 의 차이]]
>[!question]
>GQ1. 객체 지향 프로그래밍을 왜 알아야 할까?
>GQ2. 클래스와 구조체에 어떤 영향이 있을까?

## Description

 객체는 데이터와 동작들을 묶어서 하나로 관리하고, 이러한 객체를 조립해서 프로그래밍하는 것이 
 ==객체지향프로그래밍== 이다.
 
- **객체지향프로그래밍에는 4가지 특징이 있음
    - **추상화, 상속, 다형성, 캡슐화**

- **객체지향프로그래밍 좋은점 
1. 유연하고
2. 코드의 재사용을 줄이고
3. 코드의 가독성을 높이며
4. 유지보수를 용이하게 만드는 것



* ==Class와 Struct를 공부하는데 객체 지향을 알아야 하는 이유==
  
-> 클래스와 구조체는 단순한 데이터 묶음이 아니라, 객체를 만들기 위한 도구이고, 객체를 중심으로 프로그램을 설계하는 방식이 객체지향 프로그래밍이기 때문임!!

거기에 Swift 언어 또한 
객체지향 (OOP)
함수형(FP)를 
지원 하기에
둘을 자연스럽게 섞어 쓸 수 있는 언어 이기에 알아 두어야 함


``` swift
// 구조체 예시
struct Dog {
    var name: String
    var age: Int
    
    func bark() {
        print("\(name): 멍멍!")
    }
}

```

위 코드를 보면 구조체나 클래스는 단순한 데이터 저장소가 아니라..."속성(변수)과 
동작(함수)을 함께 갖는 객체" 이다

좀더 이해를 쉽게 하기 위해

``` swift

var dogName = "해피"
var dogAge = 2

func bark() {
    print("멍멍!")
}

```

위 코드는 데이터와 기능이 따로 흩어져 있어, 서로 관련이 있어도 구조상 묶여 있지 않음

``` swift

struct Dog {
    var name: String
    var age: Int

    func bark() {
        print("\(name): 멍멍!")
    }
}

```

이처럼 하나의 객체(Dog) 안에, 데이터와 행동이 함께 들어 있음 = 즉 객체 처럼 활동



좀 더 파보면 
절차적 프로그래밍 말을 알아두면 구분하기 좋음!!

## 주요 기능

+ 절차적 프로그래밍
  -> 다들 알겠지만 쉽게 말해서 위에서 아래로 후르듯 순차적인 처리가 중요시 되는 거라 생각 하면 편합니다.
  
+ 장점
1) 컴퓨터의 처리 구조와 유사해 실행 속도가 빠르다!
2) 각 프로그램의 흐름을 쉽게 추적 가능!

- 단점
1) 각 로드가 매우 유기성이 높아 유지보수가 어렵다
2) 실행순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 예상하기 어렵다!
   
``` swift
// 1. 변수 정의 (데이터)
var dogName = "해피"
var dogHungerLevel = 8  // 0~10 중 10이면 많이 배고픔

// 2. 밥 주는 함수 정의
func feedDog() {
    print("\(dogName)에게 밥을 준다 🍚")
    dogHungerLevel -= 5
    if dogHungerLevel < 0 {
        dogHungerLevel = 0
    }
}

// 3. 현재 상태 출력
func printStatus() {
    print("\(dogName)의 배고픔 수치: \(dogHungerLevel)")
}

// 4. 순서대로 실행
printStatus()
feedDog()
printStatus(

%% // 5. 실행값
해피의 배고픔 수치: 8
해피에게 밥을 준다 🍚
해피의 배고픔 수치: 3 (밥주고 나면 8-5 = 3)
 %%
 
```


``` swift

class Dog {
    var name: String
    var hungerLevel: Int
    
    init(name: String, hungerLevel: Int) {
    // 생성자 선언 
        self.name = name
        // self.name은 클래스 안에 있는 속성 오른쪽의 name은 init 매개변수
        // self를 굳이 붙이는 이유는 이건 내 속성이야 라고 구분!
        self.hungerLevel = hungerLevel
    }
// 여기서 Dog가 하나의 객체가 된다.
// init은 클래스의 생성자 이다.
// 클래스에서 객체를 만들 때 처음 값들을 넣어주는 함수


    func feed() {
        print("\(name)에게 밥을 준다 🍚")
        hungerLevel -= 5
        if hungerLevel < 0 {
            hungerLevel = 0
        }
    }
    
    func printStatus() {
        print("\(name)의 배고픔 수치: \(hungerLevel)")
    }
}

// 객체 생성
let myDog = Dog(name: "해피", hungerLevel: 8)
// 여기서 개 종류별로 만들 수 있음

let papaDog = Dog(name:"광로", hungerLevel: 5)
let kidsDog = Dog(name:"세나", hungerLevel: 3)

// 이렇게 객체 지향을 쓰면 데이터를 다루기 좋고 기능을 계속 해서 추가해서 사용 하기 좋음

// 동작
myDog.printStatus()
myDog.feed()
myDog.printStatus()

```

자 이렇게 객체 지향으로 다루면

| **항목**              | **절차적 함수 방식**                   | **객체 지향 방식**                                                  |
| ------------------- | ------------------------------- | ------------------------------------------------------------- |
| **코드 재사용성**         | 전역 변수 때문에 하나의 개체만 다룰 수 있음       | ==여러 개의 강아지를 각각 만들 수 있음 (Dog(name: "몽이", hungerLevel: 6) 등)== |
| **상태 관리**           | 데이터가 전역에 있어서 버그나 충돌 발생 가능       | 객체가 자기 상태(name, hungerLevel)를 **자기 안에 저장**함                   |
| 🧼 **캡슐화**          | 데이터와 함수가 분리돼 있어 관리 어려움          | **데이터와 기능이 한 덩어리**로 묶여 있어서 깔끔                                 |
| 👨‍👩‍👧‍👦 **확장성** | ==기능이 늘어나면 함수, 변수 다 따로 만들어야 함== | ==Dog 클래스에 기능을 계속 추가해서 자연스럽게 확장 가능 (bark(), sleep() 등)==      |








이렇게 코드로 예시를 들었지만 객체 지향에는 4가지 특성이 더 있습니다.

1. 추상화
2. 캡슐화
3. 상속
4. 다형성




* 추상화
->  프로그래밍에서 추상화는 클래스를 정의할 때 불필요한 부분들을 생략하고 객체의 속성 중 중요한 것에만 중점을 두어 개략화 하는것을 말함

![[스크린샷 2025-05-25 오후 4.37.25.png|400]]
위 사진 처럼 삼성과 아이폰의 공통점 특징은 휴대폰이라고 정의 할 수 있음.

이처럼 공통된 기능을 휴대폰에서 미리 구현하고, 상속을 통해서 공통된 기능을 삼성폰, 아이폰에 이어주면
삼성폰과 아이폰은 각자의 고유기능을 집중적으로 개발할 수 있습니다.

이렇게 하면 공통된 기능을 다시 정의할 필요가 없기에, 코드의 중복이 줄어들고, 코드의 재사용이 용이해지는 장점이 있습니다.

정리하면, 추상화로 구현해 두면, 새로운 객체를 만들 때, 클래스의 고유기능만 새로 만들어 주고, 공통된 기능은 상속을 통해서 이용가능 합니다.


* 상속
-> 여러 개체들이 지닌 공통적 특성을 부각시켜 하나의 개념이나 법칙으로 성립하 과정
![[스크린샷 2025-05-25 오후 4.49.28.png|300]]
위에서 설명한 삼성폰->휴대폰->통신기기->전자제품으로 이어지는 관계가 상속의 예라고 할 수 있습니다.
만약 삼성폰, 휴대혼, 통신기기, 전자제품은 모두 중복된 속성들이 있습니다.

**이러한 속성들을 class 마다 만들어주기보다는 공통된 속성들을 하나로 모아놓은 클래스를 만들어서, 그 클래스를 상속하면 효율적인 프로그래밍 가능

상속을 통해서 하위클래스는 상위 클래스의 변수와 기능을 물려받아서, 재사용할 수 있습니다.
이렇게 상속을 통해서 코드의 중복을 제거할 수 있습니다.

* 다형성

> 프로그래밍에서의 다형성이란 같은 자료형에 여러 가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질을 의미합니다.

![](https://blog.kakaocdn.net/dn/bYyIl9/btshZwnmysR/YuNEj8PQr1a3OhLreUzkFK/img.png)

비유적으로 표현하면, 한명의 남자는 어떠한 상황에서 여러가지 역할이 있습니다. 누군가에게는 친구가, 자식에게는 아버지, 동아리에는 동호회 리더, 아내에게는 남편, 부모님에게는 자식이 될 수 있습니다.

이처럼 객체도 상황에 따라 여러가지 형태를 가질 수 있다는 것이 다형성의 핵심입니다. 대표적인 예로는 메서드 오버라이딩과 메서드 오버로딩이 있습니다.

#### **💡메서드 오버라이딩**

- 부모 클래스의 메서드를 자식 클래스에서 재정의해서 사용하는 것을 말하며, 자식 클래스는 부모 클래스의 메서드를 재활용하면서, 독자적인 기능을 추가할 수 있다.

#### **💡메서드 오버로딩**

- 같은 이름의 메서드를 다양한 매개변수 타입과 개수로 오버로딩하여 사용하는 것을 말하며,
    오버로딩은 메서드 이름을 동일하게 유지하면서도, 다양한 상황에서 유연하게 대응할 수 있는 방법을 제공한다.

![](https://blog.kakaocdn.net/dn/baDw74/btsh2mxJeLm/XFFja9kMNjWz2DSkbSm8v0/img.png)

위 예시는 메서드 오버라이딩입니다. 메서드 오버라이딩의 예에는 휴대폰 클래스에서는 ringBell이라는 메서드가 있다고 가정하면,

삼성폰과 아이폰은 휴대폰 클래스를 상속받으며, 각각의 폰마다 벨소리가 다르기에, ringBell 메서드를 오버라이딩해서, 그들의 상황에 맞게 재정의해서 사용할 수 있습니다.

![](https://blog.kakaocdn.net/dn/ZbK0D/btsh1UuHv5Z/xKHKNbwoXsEy7tbLqZ54ak/img.png)

위 예시는 메서드 오버로딩입니다.메서드 오버로딩의 예에는 번역기 클래스에는 translate라는 메서드가 있다고 가정합시다. translate에는 숫자를 문자열로 번역해야 하고, 날짜를 문자열로 번역해야 하는 등 여러 가지 번역작업을 합니다. 

이를 위해 translate 메서드를 오버로딩해서, 매개변수 타입에 따라 다르게 동작하도록 합니다.**

이렇게 적절하게 다형성을 사용하면 코드의 재사용성과 유연성을 높이고, 불필요한 코드 중복과 결합도를 낮춰서 유지보수성을 높일 수 있습니다.

하지만 무분별한 오버로딩은 코드의 동작을 이해하는데 어려움을 줄 수 있으므로, 적절하게 사용해야 합니다.



* 캡슐화 (Encapsultation)
-> 객체지향에서의 캡슐화는 데이터와 메서드를 하나의 단위로 묶어, 외부에서 접근하지 못하도록 보호나느 개념입니다. 아래 그림처럼 데이터와 메서드를 한 곳에 모아 관리하는 것입니다.

![[스크린샷 2025-05-25 오후 4.55.22.png|500]]

**캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류입니다.**


그렇다면 캡슈화를 해야 하는 이유!!

#### **💡데이터 보호** 

- 외부로부터 클래스에 정의된 속성과 기능들을 보호

#### **💡데이터 은닉**

- 내부의 동작을 감추고 외부에는 필요한 부분만 노출

**캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문입니다.**

![](https://blog.kakaocdn.net/dn/q4OLe/btsh2G3MCn8/jIETkZhJsQ0kVU5JzoPaak/img.png)

불안정한 부분은 객체 내부로 추상화해서 변경을 최소화하고, 안전한 부분은 외부에 공개합니다.

이렇게 객체의 외부와 내부를 구분해서, 구현을 변경할 수 있는 폭은 넓어지고, 변경의 영향을 통제할 수 있습니다.

그리고 캡슐화를 통해서 코드 작성 이후 추가적인 요구사항에 유연하게 대처할 수 있습니다.
## Keywords
+ 파생된 키워드들을 작성

## References
- 참고한 레퍼런스를 작성 (예 : Apple의 공식 문서)