-> 사용자의 취향이나 행동 데이터를 분석해 개인에게 맞는 컨텐츠나 상품을 추천해주는 기술!
(ex - 넷플릭스, 유튜브, 스포티파이, 쿠팡 등등)


- ==주요 종류==
  
  -  ==협업 필터링 **(Collaborative Filtering)**==

- 사용자 기반 : 나와 비슷한 행동을 한 다른 사용자가 좋아한 컨텐츠 추천
- 아이템 기반 : 내가 좋아한 컨텐츠와 유사한 컨텐츠를 추천



-  ==**콘텐츠 기반 필터링 (Content-Based Filtering)**==
-> 내가 좋아한 아이템의 예시들을 분석해서 유사한 컨텐츠를 추천

ex) 쿠팡 - 사용자가 샤오미, 다이슨을 조회하거나 구매함
구매가 일어 날 수 있는 관련된 컨텐츠를 소개 한다 (삼성 청소기 ㅋㅋ)

넷플릭스 - SF 관련된 컨텐츠를 많이 본다면!!

-> 유사한 톤과 테마를 가진 컨텐츠 특성 기반 추천 (디스토피아, 인공지능 등등)



- ==**하이브리드 추천 (Hybrid Recommendation)**==

- 위 2가지 방식을 혼합해서 정확도를 높인 분석
- 넷플릭스, 유튜브등 대형 플랫폼이 많이 사용하는 방식



- ==**지식 기반 추천 (Knowledge-Based)**==
- 도메인 지식이나 규칙 기반으로 추천
  ex) 부동산, 보험 등 변경이 적고 사용자 선호가 명확한 도메인



- ==딥러닝 기반 추천 (딥 추천 시스템)==
->  사용자가 아이템의 관계를 벡터화하고, 신경망을 통해 복잡한 추천 패턴을 학습

ex) 유튜뷰의 "Watch Next"추천, 스포티파이의 "Discover Weekly"



* 벡터화
-> 사람이나 컨텐츠를 수치화된 특성 벡터로 표현하는 것
(컴퓨터가 패턴을 학습하고 비교할 수 있게 만들어주는 전처리 과정)

ex) 

(1) 사용자 벡터화 (성향)

|**특성**|**값**|
|---|---|
|좋아하는 장르 (Pop)|1.0|
|평균 선호 템포 (BPM)|115|
|에너지 선호도|0.75|
|댄서빌리티 선호도|0.85|
|새 음악 탐색 성향|0.6|

``` swift
[1.0, 115.0, 0.75, 0.85, 0.6]
```

사용자의 성향도 벡터로 표현된 것!


이것 왜 해야 되냐??

- 딥러닝에서는 어떻게 쓰일까?
"사용자 벡터 + 아이템 벡터" -> 신경망 입력 -> 추천 여부 예측 가능 해짐

``` swift
// 사용자 벡터: [0.9, 0.3, 0.7]   (예: 액션 선호도, 감성도, 러닝타임 선호 등)
// 영화 벡터:   [0.8, 0.4, 0.6]   (해당 영화의 특징)

→ 합쳐서 [0.9, 0.3, 0.7, 0.8, 0.4, 0.6]

→ 신경망에 넣고 학습시켜서 "이 사용자 이 영화 좋아할 확률" 출력
```

==그럼 벡터화가 중요한 이유==

1) 딥러닝은 숫자만 이해함 -> 텍스트나 카테고리도 숫자로 변환해야함
2) 벡터는 거리계산, 유사도 판단 , 연산이 쉬움
3) 유사도 = 두 벡터의 내적 (가까울수록 유사)



그럼 실제로 어떻게 추천 흐름이 되는지 ...


1) 음악 앱에서 사용자 '광로'가 좋아하는 곡

- 장르 : R&B, Hip-Hop
- 아티스트 : Tim Misch, Frank Ocean
  
  -> 이럴 경우 추천 시스템은 아래를 생각하게된
  
  1) "광로"의 과거 데이터를 기준으로 유사한 사용자들이 자주 듣는 곡
  2) R&B와 유사한 음악 장르의 최신 트렌드 (컨텐츠 기반)
  3) 광로가 자주 듣는 음악의 분위기나 BPM, 키 등 오디오 특성 (딥러닝 활용)

``` swift
1) 사용자 행동 로그
   
2) 데이터 수집 및 정제
   
3) 유사도 계산 or 딥러닝 모델 학습

4) 적합한 컨텐츠 추천

5) 사용자의 피드백 수집 -> 반복 계산
```


- 핵심 지표
  
**1.** **Precision / Recall**

- 정밀도 : 추천한 항목 중 사용자가 실제로 좋아한 항목의 비율
- 재현율 : 사용자가 좋아한 항목 중 추천된 항목의 비율

ex) 
Precision  = 6/10 = 0.6
(사용자가 좋아한 전체 10 중 6개가 추천되었으면)
  
  
  
 **2.**  **Click-through Rate (CTR)**
 - 사용자가 추천된 항목을 클릭한 비율

CTR = 클릭수 / 노출수


 **3.**  **Engagement Time**

-> 컨텐츠를 얼마나 오랫동안 소비했는지
ex) 음악 재생 시간, 영상 시청 시간


**4.**  **Diversity / Novelty**

- Diversity : 추천 항목 간의 다양성
- Novelty : 사용자가 처음 접하는 새로움

ex) 다양한 스타일 제공




### 스포티파이 는 어떻게 추천 하고 있나요?

1. Match fan and artist
   ![[스크린샷 2025-07-01 오후 3.23.28.png]]

각 플랫폼 별로 컨셉이 있지만, 스포티파이의 컨셉은 (아티스트와 펜의 연결고리) 입니다.


Verse 1. 협업 필터링 (Collaborative Filtering)

-> 과거에 스포티파이가 사용하던 시스템으로 비슷한 취향을 가진 사용자가 좋아한 음악을 추천하는 방법 입니다.

사용자, 아이템, 사용자의 피드백 (평점, 리뷰, 좋아요) 데이터를 바탕으로 추천을 해줍니다.
사용자의 데이터를 기반으로 사용자에게 유사항 음악을 추천해줌

하지만 이 부분에는 치명적인 문제가 있습니다.


-> 사용자에게 새로 출시한 노래와 인기가 없는 노래를 추천할 수 없다는 점입니다.
분석할 데이터가 없으면 협업 필터링 접근 방식은 결국 무너질 수 밖에 없습니다.
이것을 콜드 스타트 문제라고 함


여기서 스포티파이 R&D팀의 고민은

1) 새로운 음악이 출시되면 바로 추천해줄 수 있고,
2) 사용자들이 들어본 적이 없는 멋진 음악을 추천해주는 것입니다.

그래서 나온 것이...


Verse 2. BaRT (Bandits for Recommendations as Treatments) 알고리즘
-> 사용자의 **선호도 + 반응 데이터**를 바탕으로 콘텐츠를 **개인화** + **설명 가능하게 추천**함

![[스크린샷 2025-07-01 오후 3.28.04.png]]
   **왼쪽 (BaRT)**

- 추천 알고리즘이 작동하는 영역
- 여러 가지 후보 콘텐츠 중 어떤 콘텐츠를 어떤 방식으로 노출할지를 결정
- **Bandit 알고리즘** 기반의 실험과 학습이 핵심

 **가운데 (Spotify UI)**

- 유저에게 보이는 Home 화면 (예: “Your Release Radar”, “Daily Mix 1”)
- BaRT가 어떤 콘텐츠를 보여줄지 결정하고, UI는 이를 시각적으로 렌더링


![[스크린샷 2025-07-01 오후 3.28.12.png]]

1) BaRT는 사용자 맞춤 컨텐츠 큐레이션을 위해 MAB 알고리즘을 기반으로 합니다.
2) 스포티파이 홈 화면이 그 결과가 나타남
3) 사용자가 스트리밍을 하면 행동 데이터 수집
4) 이 데이터가 다시 알고리즘에 반영되어 더 정교해짐
   
   그럼 MAB알고리즘은 뭐냐 ..
   
   - MAB (Multi-armed Bandit) 알고리즘
-> 도박기계 슬롯머신에서 따옴.
각각의 슬롯머신은 보상 확률이 다르고, 사용자는 어느 레버를 당겨야 보상이 높은지 학습해 나가야함


**핵심 개념: Explore vs Exploit (탐색 vs 활용)**

- **Explore (탐색)**: 새로운 콘텐츠를 시도 → 더 좋은 추천 가능성 발굴
- **Exploit (활용)**: 이미 반응이 좋았던 콘텐츠를 더 많이 보여줌
  
  ex) 
- **Exploit**: Frank Ocean 많이 듣는 유저에게 더 많은 R&B 추천
- **Explore**: 가끔은 Jazz도 살짝 추천해서 반응을 테스트

이 2가지를 활용하는 이유 (새로운 시도 VS 기존 인기 컨텐츠 활용의 균형


즉, BaRT알고리즘은 사용자의 호불호를 학습하고, 이에 따라 사용자가 듣고 싶어하는 다른 음악을 추천하도록 결정합니다. 스포티파이의 선곡은 슬롯머신에 베팅하는 방식과 비슷한데,
사용자가 스포티파이의 추천된 음악을 들었다면, 스포티 파이는 그걸 학습하는 것이죠


Verse 3. 스포티파이의 추천 알고리즘 성공 기준 "단 30초"

- 스포티파이는 추천된 음악을 30초 이상 들었을 때 알고리즘의 추천이 성공했다고 판단합니다. 사용자들이 추천된 음악을 실제로 듣는지, 얼마나 자주 듣는지에 대해 재생 시간을 확인합니다.
   따라서 노래의 처음 29초가 마음에 들지 않으면 다시 들을 필요가 없도록 29초전에 건너뛰면 좀 더 취향에 맞는 음악 추천을 받을 수 있습니다.


### 그럼 설계하는 방법
실패 ...

