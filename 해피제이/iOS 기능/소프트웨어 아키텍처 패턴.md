>[!question]
>GQ1. MV 패턴은 무엇인가 ?
>GQ2. MVVM 패턴은 무엇인가 ?
>GQ3. MVI 패턴은 무엇인가 ?
>GQ4. 각각 차이점은 무엇인가?

소프트웨어 아키텍처 패턴으로 UI(화면)과 로직을 깔끔하게 분리해서 **유지보수**와 **테스트**를 쉽게 해주는 구조

---

## **🤔 GQ1. SwiftUI에서의 MV(Model-View) 아키텍처**

---

### **✅ 개념 정리**

**MV는 Model과 View를 분리해서 앱을 구성하는 기본적인 구조예제**

---

### **🧠 Model (모델)**

- 데이터와 비즈니스 로직 담당
- 주로 struct, class, API 호출 등으로 구현

```
struct Product {
    let name: String
    let price: Double
}
```

---

### **🖼️ View (뷰)**

- 사용자에게 보여지는 UI 화면
- @State, @Binding, 또는 그냥 let model로 직접 접근 가능

```
struct ContentView: View {
    let person = Person(name: "해피제이")

    var body: some View {
        Text("Hello, \\(person.name)!")
            .font(.title)
    }
}
```

---

### **📌 MV 데이터 흐름**

```
사용자 입력 → View → 직접 Model 사용 → 화면에 표시
```

View는 Model을 직접 사용해서 데이터를 보여줍니다. 중간 계층 없음.

---

### **✅ 전체 예시**

```
// Model
struct User {
    let name: String
    let age: Int
}

// View
struct UserView: View {
    let user: User

    var body: some View {
        VStack {
            Text("Name: \\(user.name)")
            Text("Age: \\(user.age)")
        }
    }
}

// ContentView
struct ContentView: View {
    var body: some View {
        UserView(user: User(name: "해피제이", age: 28))
    }
}
```

---

### **✅ SwiftUI에서 MV의 장단점**

|**항목**|**설명**|
|---|---|
|✅ 장점|구조가 간단하고 빠르게 개발 가능|
|❌ 단점|View에 로직이 섞이면 유지보수 어려움, 규모가 커지면 비효율|

---

> ✅ 그래서 복잡한 앱에서는
> 
> **MVVM**
> 
> View와 Model 사이에 ViewModel을 넣으면 더 좋은 구조가 됨.

---

## **🤔 SwiftUI에서의 MVVM 아키텍처 패턴**

---

### **🧱 MVVM이란?**

> **Model-View-ViewModel**의 약자 **UI(View)**와 **데이터/로직(Model)** 사이에 **중간 관리자(ViewModel)**를 두어 역할을 분리한 구조

---

### **🧩 구성 요소**

### **✅ 1. Model (모델)**

- 앱의 데이터, 로직 담당
- struct, class, API 처리 등

```
struct Person {
    let name: String
}
```

---

### **✅ 2. ViewModel (뷰모델)**

- Model 데이터를 가공해서 View에 전달
- View의 이벤트를 처리하고, Model을 업데이트
- SwiftUI에서는 @Published, @ObservedObject로 바인딩

```
import Combine

class PersonViewModel: ObservableObject {
    @Published var nameText: String = ""

    init(person: Person) {
        self.nameText = "Hello, \\(person.name)!"
    }
}
```

---

### **✅ 3. View (뷰)**

- 사용자에게 보여지는 화면
- ViewModel을 구독하여 UI 자동 갱신

```
struct ContentView: View {
    @StateObject private var viewModel = PersonViewModel(person: Person(name: "해피제이"))

    var body: some View {
        Text(viewModel.nameText)
            .font(.title)
    }
}
```

---

### **🔁 MVVM 데이터 흐름**

```
Model → ViewModel → View
       ↑         ↓
    사용자 입력 → ViewModel → Model 업데이트
```

---

### **✅ MVVM의 장점**

|**항목**|**설명**|
|---|---|
|👓 뷰와 로직 분리|View는 UI에만 집중하고, 로직은 ViewModel이 담당|
|🔁 자동 갱신|상태 바인딩으로 UI 자동 업데이트|
|🧪 테스트 쉬움|ViewModel만 따로 테스트 가능|
|📦 재사용성 ↑|View와 ViewModel을 분리해 다양한 곳에 재사용 가능|

---

### **🧠 언제 MVVM을 쓰면 좋을까?**

- 화면이 복잡하거나 동적인 UI가 많을 때
- 로직이 많아 View에 코드가 몰릴 때
- 팀 프로젝트에서 역할을 분리하고 싶을 때

---

### **✅ 전체 구조 요약**

```
// Model
struct Person {
    let name: String
}

// ViewModel
class PersonViewModel: ObservableObject {
    @Published var nameText: String = ""

    init(person: Person) {
        self.nameText = "Hello, \\(person.name)!"
    }
}

// View
struct ContentView: View {
    @StateObject private var viewModel = PersonViewModel(person: Person(name: "해피제이"))

    var body: some View {
        Text(viewModel.nameText)
            .font(.title)
    }
}
```

---

## **🤔 SwiftUI에서의 MVI(Model–View–Intent) 아키텍처**

---

### **🧱 MVI란?**

> Model - View - Intent **단방향 데이터 흐름(Unidirectional Data Flow)**을 기반으로 한 아키텍처 패턴

📌 **Intent**는 사용자 액션(이벤트)을 의미하고,

**Model**은 상태(State),

**View**는 상태를 화면에 그리는 역할

---

### **🎯 핵심 특징**

- 모든 **상태(State)**는 단일 데이터 구조로 관리
    
- *Intent(사용자 입력)**가 발생하면,
    
    → **Reducer/Intent**가 상태를 계산하고
    
    → **새로운 상태**를 Model로 반환
    
    → View가 새 상태를 반영하여 업데이트됨
    

---

### **🧩 구성 요소**

### **✅ 1. Model (State)**

- 앱의 상태를 표현하는 단일 구조체

```
struct CounterState {
    var count: Int = 0
}
```

---

### **✅ 2. Intent / Action**

- 사용자의 입력이나 UI 이벤트를 enum으로 정의

```
enum CounterIntent {
    case increment
    case decrement
}
```

---

### **✅ 3. Reducer (상태 변경 로직)**

- 현재 상태와 액션을 받아서 새로운 상태를 반환

```
func reduce(state: CounterState, intent: CounterIntent) -> CounterState {
    var newState = state
    switch intent {
    case .increment:
        newState.count += 1
    case .decrement:
        newState.count -= 1
    }
    return newState
}
```

---

### **✅ 4. ViewModel (상태 관리)**

- 상태를 @Published로 관리하고, Intent를 받아 처리

```
class CounterViewModel: ObservableObject {
    @Published private(set) var state = CounterState()

    func send(_ intent: CounterIntent) {
        state = reduce(state: state, intent: intent)
    }
}
```

---

### **✅ 5. View**

- 상태를 기반으로 UI를 표시, 버튼으로 Intent 전달

```
struct ContentView: View {
    @StateObject private var viewModel = CounterViewModel()

    var body: some View {
        VStack(spacing: 20) {
            Text("Count: \\(viewModel.state.count)")
                .font(.largeTitle)

            HStack {
                Button("➖") {
                    viewModel.send(.decrement)
                }
                Button("➕") {
                    viewModel.send(.increment)
                }
            }
        }
    }
}
```

---

### **🔁 MVI 데이터 흐름 요약**

```
[View] → 사용자 입력 발생 → [Intent]
→ ViewModel이 Intent 처리 → [Reducer] → 새로운 상태 생성
→ [Model(State)] → View 갱신
```

---

### **✅ MVI 장점**

|**항목**|**설명**|
|---|---|
|📦 상태 단일화|모든 UI 상태가 하나의 구조로 관리됨|
|🧼 예측 가능한 흐름|Intent → 상태 → UI 갱신 순서가 명확|
|🔁 재현 가능|상태 변화가 기록되면 디버깅, 롤백이 쉬움|
|🔬 테스트 용이|Intent와 Reducer를 단위 테스트하기 쉬움|

---

### **❗️주의점**

- 구조가 좀 무거울 수 있음 (작은 화면에는 과할 수도 있음)
- 상태가 복잡해질수록 코드도 많아짐

---

## **✅ 전체 구조 예시 요약**

```
// 1. 상태
struct CounterState {
    var count: Int = 0
}

// 2. 사용자 액션
enum CounterIntent {
    case increment, decrement
}

// 3. 상태 변경
func reduce(state: CounterState, intent: CounterIntent) -> CounterState {
    var newState = state
    switch intent {
    case .increment:
        newState.count += 1
    case .decrement:
        newState.count -= 1
    }
    return newState
}

// 4. ViewModel
class CounterViewModel: ObservableObject {
    @Published private(set) var state = CounterState()

    func send(_ intent: CounterIntent) {
        state = reduce(state: state, intent: intent)
    }
}

// 5. View
struct ContentView: View {
    @StateObject private var viewModel = CounterViewModel()

    var body: some View {
        VStack {
            Text("Count: \\(viewModel.state.count)")
            HStack {
                Button("➖") { viewModel.send(.decrement) }
                Button("➕") { viewModel.send(.increment) }
            }
        }
    }
}원하는 형식에 딱 맞게 더 압축하거나 확장도 가능해!
```

---

## **🤔 MV vs MVVM vs MVI 비교표 (SwiftUI 기준)**

|**항목**|**MV (Model-View)**|**MVVM (Model-View-ViewModel)**|**MVI (Model-View-Intent)**|
|---|---|---|---|
|🧱 구조|Model ↔ View|Model ←→ ViewModel ←→ View|View → Intent → Reducer → State → View|
|🎯 핵심 개념|데이터와 UI만 존재|중간 계층(ViewModel)으로 역할 분리|단일 상태 + Intent로 상태 관리|
|🔁 데이터 흐름|양방향 또는 직접 연결|ViewModel 중심 양방향 바인딩|**단방향 흐름** (Unidirectional)|
|📦 상태 관리|View가 직접 Model 참조|ViewModel이 상태 가공 후 전달|ViewModel이 State 전체를 관리|
|⚙️ 사용자 입력 처리|View 내부에서 처리|View → ViewModel로 전달|View → Intent → Reducer 처리|
|🧪 테스트 용이성|낮음 (로직이 View에 섞임)|높음 (ViewModel만 테스트 가능)|매우 높음 (Intent/Reducer 테스트 용이)|
|📐 구조 복잡도|가장 간단함|중간 정도|가장 복잡하지만 확장성 좋음|
|📱 적합한 상황|아주 간단한 화면|일반적인 앱 화면, 로직 분리 필요 시|복잡한 UI, 상태 추적/로그 필요할 때|
|📌 예시 키워드|Text("Hello") + 모델 바로 사용|@ObservedObject, @Published|State, Intent, Reducer, send()|

---

### **📌 요약 정리**

- **MV**
    
    👉 가장 간단. 빠르게 만들 수 있지만 유지보수에 약함
    
- **MVVM**
    
    👉 SwiftUI에서 가장 많이 쓰임. 적당히 깔끔하고 구조적
    
- **MVI**
    
    👉 상태 관리가 완벽하지만, 구조가 무거워서 복잡한 앱에 적합
    

---

dsfdsf